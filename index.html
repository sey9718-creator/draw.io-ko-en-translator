<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>draw.io Translator (KOâ†”EN)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
  <style>
    body { font-family: system-ui, sans-serif; max-width: 980px; margin: 24px auto; padding: 0 12px; }
    header { display:flex; align-items:center; justify-content:space-between; }
    .card { border:1px solid #ddd; border-radius:12px; padding:16px; margin-top:16px; }
    label { display:block; font-weight:600; margin:10px 0 6px; }
    input, select, textarea, button { width:100%; padding:10px; border:1px solid #ccc; border-radius:8px; }
    button { cursor:pointer; font-weight:600; }
    .row { display:grid; grid-template-columns:1fr 1fr; gap:12px; }
    .hint{ color:#666; font-size:12px; }
    .ok{ color:#0a7; font-size:12px; }
    .bad{ color:#c33; font-size:12px; }
    .progress { height:10px; background:#eee; border-radius:999px; overflow:hidden; margin-top:8px; }
    .bar { height:100%; width:0%; background:#4f46e5; transition: width .2s ease; }
    pre#log { background:#0b1020; color:#d6e1ff; padding:10px; border-radius:8px; height:180px; overflow:auto; font-size:12px; }
  </style>
</head>
<body>
<header>
  <h1>draw.io Translator</h1><small>KO â†” EN</small>
</header>

<div class="card">
  <div class="row">
    <div>
      <label>ë²ˆì—­ ì œê³µì</label>
      <select id="provider">
        <option value="deepl">DeepL</option>
        <option value="gcp">Google Cloud Translation</option>
        <option value="azure">Azure Translator</option>
      </select>
    </div>
    <div>
      <label>API Key (ì„¸ì…˜ì—ë§Œ ì €ì¥)</label>
      <input id="apiKey" type="password" placeholder="API í‚¤ ì…ë ¥" />
      <div class="hint">ìƒˆë¡œê³ ì¹¨ ì‹œ ì‚¬ë¼ì§‘ë‹ˆë‹¤. ì„œë²„ ì €ì¥ ì—†ìŒ.</div>
    </div>
  </div>

  <div class="row" style="margin-top:12px;">
    <div>
      <label>Source</label>
      <select id="sourceLang">
        <option value="KO">KO</option>
        <option value="EN">EN</option>
      </select>
    </div>
    <div>
      <label>Target</label>
      <select id="targetLang">
        <option value="EN">EN</option>
        <option value="KO">KO</option>
      </select>
    </div>
  </div>

  <label style="margin-top:12px;">do-not-translate íŒ¨í„´ (ì„ íƒ, ì •ê·œì‹Â·ì‰¼í‘œ êµ¬ë¶„)</label>
  <input id="dnt" placeholder="ë¹„ì›Œë„ ë©ë‹ˆë‹¤. ì˜ˆ) https?:\/\/\S+, [A-Z]{2,}, \$\w+, \{\{[^}]+\}\}" />

  <label>ê¸€ë¡œì„œë¦¬ (ì„ íƒ, JSON)</label>
  <textarea id="glossary" rows="3" placeholder='{"í›„ì›":"donation","ì •ê¸°í›„ì›":"monthly pledge"}'></textarea>

  <label>draw.io íŒŒì¼ ì—…ë¡œë“œ (.drawio/.xml)</label>
  <input id="file" type="file" accept=".drawio,.xml" />
  <div id="status" class="hint"></div>

  <div class="row" style="margin-top:12px;">
    <button id="translateBtn">ë²ˆì—­ ì‹¤í–‰</button>
    <button id="cancelBtn" disabled>ì·¨ì†Œ</button>
  </div>

  <div class="progress"><div class="bar" id="bar"></div></div>
  <div class="hint" id="meter" style="text-align:right;">0 / 0</div>

  <label style="margin-top:12px;">ìƒíƒœ ë¡œê·¸</label>
  <pre id="log"></pre>

  <div class="row" style="margin-top:12px;">
    <button id="downloadBtn" disabled>ë²ˆì—­ëœ íŒŒì¼ ë‹¤ìš´ë¡œë“œ</button>
    <button id="testProxyBtn">í”„ë¡ì‹œ í…ŒìŠ¤íŠ¸</button>
  </div>
</div>

<script>
  // === ê¼­ ë³¸ì¸ Cloudflare Worker ì£¼ì†Œë¡œ êµì²´ ===
  // /translate ë¶™ì¼ í•„ìš” ì—†ìŠµë‹ˆë‹¤. Cloudflareê°€ ì•Œë ¤ì¤€ ì£¼ì†Œ ê·¸ëŒ€ë¡œ OK.
  const proxyURL = "https://drawiotranslator.eyseong.workers.dev/";

  const statusEl = document.getElementById('status');
  const fileEl = document.getElementById('file');
  const translateBtn = document.getElementById('translateBtn');
  const cancelBtn = document.getElementById('cancelBtn');
  const downloadBtn = document.getElementById('downloadBtn');
  const testProxyBtn = document.getElementById('testProxyBtn');

  const providerEl = document.getElementById('provider');
  const apiKeyEl = document.getElementById('apiKey');
  const sourceLangEl = document.getElementById('sourceLang');
  const targetLangEl = document.getElementById('targetLang');
  const dntEl = document.getElementById('dnt');
  const glossaryEl = document.getElementById('glossary');

  const bar = document.getElementById('bar');
  const meter = document.getElementById('meter');
  const logEl = document.getElementById('log');

  let originalXmlText = null;
  let translatedXmlText = null;
  let aborter = null;

  // ì „ì—­ ì—ëŸ¬ë„ í™”ë©´ì— ì°ê¸°
  window.addEventListener('error', (e) => log(`[window.error] ${e.message}`));
  window.addEventListener('unhandledrejection', (e) => log(`[promise.reject] ${e.reason}`));

  // ì„¸ì…˜ ì €ì¥/ë³µì›
  apiKeyEl.value = sessionStorage.getItem('DRAWIO_TR_KEY') || '';
  apiKeyEl.addEventListener('input', () => sessionStorage.setItem('DRAWIO_TR_KEY', apiKeyEl.value || '') );

  fileEl.addEventListener('change', async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    originalXmlText = await file.text();
    status("íŒŒì¼ ë¡œë“œ ì™„ë£Œ");
  });

  // í”„ë¡ì‹œ/í‚¤ ê°„ë‹¨ ì ê²€
  testProxyBtn.addEventListener('click', async () => {
    try {
      if (!/^https?:\/\//i.test(proxyURL)) return status("proxyURLì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤. ë¨¼ì € ì„¤ì •í•˜ì„¸ìš”.", true);
      const apiKey = apiKeyEl.value.trim();
      if (!apiKey) return status("API í‚¤ë¥¼ ë¨¼ì € ì…ë ¥í•˜ì„¸ìš”", true);

      const body = { provider: providerEl.value, apiKey, source: "KO", target: "EN", q: "ì•ˆë…•í•˜ì„¸ìš”" };
      const res = await fetchWithTimeout(proxyURL, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body) }, 15000);
      const txt = await res.text();
      log(`[TEST] status=${res.status} body=${txt}`);
      if (!res.ok) status("í”„ë¡ì‹œ/í‚¤ ì ê²€ í•„ìš”: " + txt, true);
      else status("í”„ë¡ì‹œ OK (í…ŒìŠ¤íŠ¸ ì™„ë£Œ)");
    } catch (e) {
      log(`[TEST-ERR] ${e}`);
      status("í”„ë¡ì‹œ í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: " + e.message, true);
    }
  });

  translateBtn.addEventListener('click', async () => {
    resetProgress();
    try {
      if (!/^https?:\/\//i.test(proxyURL)) return status("proxyURLì´ ë¹„ì–´ìˆê±°ë‚˜ ì˜ëª»ë˜ì—ˆìŠµë‹ˆë‹¤. Worker ì£¼ì†Œë¥¼ ë¨¼ì € ë„£ì–´ì£¼ì„¸ìš”.", true);
      if (!originalXmlText) return status("íŒŒì¼ì„ ë¨¼ì € ì—…ë¡œë“œí•˜ì„¸ìš”", true);

      const apiKey = apiKeyEl.value.trim();
      if (!apiKey) return status("API í‚¤ë¥¼ ì…ë ¥í•˜ì„¸ìš”", true);
      if (sourceLangEl.value === targetLangEl.value) return status("Source/Targetì„ ë‹¤ë¥´ê²Œ ì„¤ì •í•˜ì„¸ìš”", true);

      aborter = new AbortController();
      cancelBtn.disabled = false;
      translateBtn.disabled = true;
      downloadBtn.disabled = true;

      const parser = new DOMParser();
      const doc = parser.parseFromString(originalXmlText, "text/xml");
      const diagrams = Array.from(doc.getElementsByTagName('diagram'));
      if (diagrams.length === 0) return status("diagram ë…¸ë“œë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.", true);

      const dntRegexes = parseRegexList(dntEl.value); // ë¹„ì–´ ìˆì–´ë„ OK
      const glossary = tryParseJSON(glossaryEl.value) || {};

      // ë²ˆì—­ ëŒ€ìƒ ìˆ˜ì§‘
      const tasks = [];
      for (const diagram of diagrams) {
        const innerXml = inflateIfNeeded(diagram.textContent || '');
        const innerDoc = parser.parseFromString(innerXml, "text/xml");
        const cells = Array.from(innerDoc.getElementsByTagName('mxCell'));
        for (const cell of cells) {
          const rawVal = cell.getAttribute('value');
          if (!rawVal) continue;
          const plain = htmlToPlainText(decodeHtmlEntities(rawVal)).trim();
          if (!plain) continue;
          tasks.push({ diagram, innerDoc, cell });
        }
      }

      const total = tasks.length;
      let done = 0; updateMeter(done, total);

      // ì‹¤í–‰
      for (const t of tasks) {
        if (aborter.signal.aborted) throw new Error('ì‚¬ìš©ì ì·¨ì†Œ');

        const rawVal = t.cell.getAttribute('value');
        const htmlDecoded = decodeHtmlEntities(rawVal);
        const plainText = htmlToPlainText(htmlDecoded).trim();

        const {protectedText, placeholders} = protectTokens(plainText, dntRegexes);
        const glApplied = applyGlossaryBefore(protectedText, glossary);
        const translated = await translateText(glApplied, sourceLangEl.value, targetLangEl.value, providerEl.value, apiKey, aborter.signal);
        const restored = restoreTokens(applyGlossaryAfter(translated, glossary), placeholders);

        t.cell.setAttribute('value', encodeHtmlEntities(restored));

        done++; updateMeter(done, total);
        if (done % 10 === 0) log(`ì§„í–‰: ${done}/${total}`);
      }

      // diagramë³„ ë°˜ì˜
      const byDiagram = new Map();
      for (const t of tasks) {
        if (!byDiagram.has(t.diagram)) byDiagram.set(t.diagram, t.innerDoc);
      }
      for (const [diagram, innerDoc] of byDiagram.entries()) {
        const newInnerXml = new XMLSerializer().serializeToString(innerDoc.documentElement);
        diagram.textContent = deflateToBase64(newInnerXml);
      }

      translatedXmlText = new XMLSerializer().serializeToString(doc);
      status("ë²ˆì—­ ì™„ë£Œ!");
      downloadBtn.disabled = false;

    } catch (e) {
      console.error(e);
      log(`[ERR] ${e?.message || e}`);
      status("ë²ˆì—­ ì‹¤íŒ¨: " + (e?.message || e), true);
    } finally {
      translateBtn.disabled = false;
      cancelBtn.disabled = true;
      aborter = null;
    }
  });

  cancelBtn.addEventListener('click', () => {
    if (aborter) {
      aborter.abort();
      status("ì·¨ì†Œ ìš”ì²­ë¨(ì ì‹œ í›„ ì¤‘ë‹¨).", true);
      log("[USER] Abort requested");
    }
  });

  downloadBtn.addEventListener('click', () => {
    if (!translatedXmlText) return;
    const blob = new Blob([translatedXmlText], {type: 'application/xml'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'translated.drawio';
    a.click();
  });

  // ===== Utils =====
  function status(msg, isError=false){ statusEl.textContent = msg; statusEl.className = isError ? 'bad':'ok'; }
  function log(s){ logEl.textContent += s + '\n'; logEl.scrollTop = logEl.scrollHeight; }
  function resetProgress(){ bar.style.width='0%'; meter.textContent='0 / 0'; logEl.textContent=''; status(''); }
  function updateMeter(done, total){ meter.textContent = `${done} / ${total}`; bar.style.width = total ? `${Math.floor(done/total*100)}%` : '0%'; }

  function inflateIfNeeded(data){
    try { const bin = atob(data); const bytes = new Uint8Array([...bin].map(c=>c.charCodeAt(0)));
      return new TextDecoder('utf-8').decode(pako.inflateRaw(bytes));
    } catch { return data; }
  }
  function deflateToBase64(xmlStr){
    const bytes = pako.deflateRaw(new TextEncoder().encode(xmlStr));
    let bin=''; for(const b of bytes) bin += String.fromCharCode(b); return btoa(bin);
  }
  function decodeHtmlEntities(s){ const e=document.createElement('textarea'); e.innerHTML=s; return e.value; }
  function encodeHtmlEntities(s){ const e=document.createElement('textarea'); e.textContent=s; return e.innerHTML; }
  function htmlToPlainText(html){ return html.replace(/<br\s*\/?>/gi,'\n').replace(/<[^>]+>/g,''); }
  function parseRegexList(s){ if(!s?.trim()) return []; return s.split(',').map(x=>x.trim()).filter(Boolean).map(p=>new RegExp(p,'g')); }

  // ğŸ”§ ë²„ê·¸ ìˆ˜ì •: ì˜¬ë°”ë¥¸ ê°ì²´ ë¦¬í„°ëŸ´ ì‚¬ìš©
  function protectTokens(text, regexes){
    const placeholders=[]; let out=text;
    regexes.forEach((rgx,i)=>{
      out = out.replace(rgx,(m)=>{
        const token=`__DNT_${i}_${placeholders.length}__`;
        placeholders.push({ token, value: m }); // â† ì—¬ê¸°!
        return token;
      });
    });
    return { protectedText: out, placeholders };
  }

  function restoreTokens(text, placeholders){ let res=text; for(const {token,value} of placeholders){ res = res.split(token).join(value); } return res; }
  function tryParseJSON(s){ if(!s?.trim()) return null; try{ return JSON.parse(s);}catch{ return null;} }
  function applyGlossaryBefore(text, gl){
    let out=text; for(const [src,tgt] of Object.entries(gl)){ const rgx=new RegExp(src.replace(/[.*+?^${}()|[\]\\]/g,'\\$&'),'g'); out = out.replace(rgx, tgt); } return out;
  }
  function applyGlossaryAfter(text, gl){ return text; }

  async function translateText(text, source, target, provider, apiKey, signal){
    const parts = chunkByLines(text, 1900);
    const out = [];
    for (const part of parts){
      const payload = { provider, apiKey, source, target, q: part };
      const res = await fetchWithTimeout(proxyURL, {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify(payload),
        signal
      }, 20000);
      const t = await res.text();
      if (!res.ok) throw new Error(`Proxy ${res.status}: ${t}`);
      const data = JSON.parse(t);
      out.push(data.translatedText || '');
    }
    return out.join('\n');
  }

  function chunkByLines(s, max){
    const lines = s.split(/\n/); const chunks=[]; let cur='';
    for (const ln of lines){ if ((cur + '\n' + ln).length > max) { if(cur) chunks.push(cur); cur = ln; } else { cur = cur ? cur+'\n'+ln : ln; } }
    if (cur) chunks.push(cur); return chunks;
  }

  // fetch íƒ€ì„ì•„ì›ƒ ë³´ì¡°
  async function fetchWithTimeout(resource, options = {}, timeoutMs = 20000) {
    const externalSignal = options.signal;
    const controller = new AbortController();
    const signals = [controller.signal];
    if (externalSignal) {
      externalSignal.addEventListener('abort', () => controller.abort(), { once: true });
    }
    const id = setTimeout(() => controller.abort(), timeoutMs);
    try { return await fetch(resource, { ...options, signal: controller.signal }); }
    finally { clearTimeout(id); }
  }
</script>
</body>
</html>
